{"version":3,"file":"index.modern.js","sources":["../index.ts"],"sourcesContent":["import {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport ResizeObserver from \"resize-observer-polyfill\";\n\nexport type TOptions = {\n  maxFontSize?: number;\n  minFontSize?: number;\n  onFinish?: (fontSize: number) => void;\n  onStart?: () => void;\n  resolution?: number;\n};\n\n// suppress useLayoutEffect warning when rendering on the server\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nconst useIsoLayoutEffect =\n  typeof window !== \"undefined\" &&\n  window.document &&\n  window.document.createElement\n    ? useLayoutEffect\n    : useEffect;\n\nconst useFitText = ({\n  maxFontSize = 100,\n  minFontSize = 20,\n  onFinish,\n  onStart,\n  resolution = 5,\n}: TOptions = {}) => {\n  const initState = useCallback(() => {\n    onStart && onStart();\n    return {\n      fontSize: maxFontSize,\n      fontSizePrev: minFontSize,\n      fontSizeMax: maxFontSize,\n      fontSizeMin: minFontSize,\n    };\n  }, [maxFontSize, minFontSize, onStart]);\n\n  const ref = useRef<HTMLDivElement>(null);\n  const isFirstResizeRef = useRef(true);\n  const [state, setState] = useState(initState);\n  const { fontSize, fontSizeMax, fontSizeMin, fontSizePrev } = state;\n\n  // montior div size changes and recalculate on resize\n  let animationFrameId: number | null = null;\n  const [ro] = useState(\n    () =>\n      new ResizeObserver(() => {\n        animationFrameId = window.requestAnimationFrame(() => {\n          // don't reset the state the first time so it won't be reset\n          // twice consecutively on first load\n          if (!isFirstResizeRef.current) {\n            setState(initState());\n          }\n          isFirstResizeRef.current = false;\n        });\n      }),\n  );\n\n  useEffect(() => {\n    if (ref.current) {\n      ro.observe(ref.current);\n    }\n    return () => {\n      animationFrameId && window.cancelAnimationFrame(animationFrameId);\n      ro.disconnect();\n    };\n  }, [animationFrameId, ro]);\n\n  // check overflow and resize font\n  useIsoLayoutEffect(() => {\n    const isWithinResolution = Math.abs(fontSize - fontSizePrev) <= resolution;\n    const isOverflow =\n      !!ref.current &&\n      (ref.current.scrollHeight > ref.current.offsetHeight ||\n        ref.current.scrollWidth > ref.current.offsetWidth);\n    const isAsc = fontSize > fontSizePrev;\n\n    // return if the font size has been adjusted \"enough\" (change within `resolution`)\n    // reduce font size by one increment if it's overflowing\n    if (isWithinResolution) {\n      if (isOverflow) {\n        const fontSizeNew =\n          fontSizePrev < fontSize\n            ? fontSizePrev\n            : fontSize - (fontSizePrev - fontSize);\n        setState({\n          fontSize: fontSizeNew,\n          fontSizeMax,\n          fontSizeMin,\n          fontSizePrev,\n        });\n      } else {\n        onFinish && onFinish(fontSize);\n      }\n      return;\n    }\n\n    // binary search to adjust font size\n    let delta: number;\n    let newMax = fontSizeMax;\n    let newMin = fontSizeMin;\n    if (isOverflow) {\n      delta = isAsc ? fontSizePrev - fontSize : fontSizeMin - fontSize;\n      newMax = Math.min(fontSizeMax, fontSize);\n    } else {\n      delta = isAsc ? fontSizeMax - fontSize : fontSizePrev - fontSize;\n      newMin = Math.max(fontSizeMin, fontSize);\n    }\n    setState({\n      fontSize: fontSize + delta / 2,\n      fontSizeMax: newMax,\n      fontSizeMin: newMin,\n      fontSizePrev: fontSize,\n    });\n  }, [\n    fontSize,\n    fontSizeMax,\n    fontSizeMin,\n    fontSizePrev,\n    onFinish,\n    ref,\n    resolution,\n  ]);\n\n  return { fontSize: `${fontSize}%`, ref };\n};\n\nexport default useFitText;\n"],"names":["useIsoLayoutEffect","window","document","createElement","useLayoutEffect","useEffect","maxFontSize","minFontSize","onFinish","onStart","resolution","initState","useCallback","fontSize","fontSizePrev","fontSizeMax","fontSizeMin","ref","useRef","isFirstResizeRef","state","setState","useState","animationFrameId","ro","ResizeObserver","requestAnimationFrame","current","observe","cancelAnimationFrame","disconnect","isWithinResolution","Math","abs","isOverflow","scrollHeight","offsetHeight","scrollWidth","offsetWidth","isAsc","delta","newMax","newMin","min","max"],"mappings":"0IAmBA,MAAMA,EACc,oBAAXC,QACPA,OAAOC,UACPD,OAAOC,SAASC,cACZC,EACAC,gBAEa,EACjBC,YAAAA,EAAc,IACdC,YAAAA,EAAc,GACdC,SAAAA,EACAC,QAAAA,EACAC,WAAAA,EAAa,GACD,MACZ,MAAMC,EAAYC,EAAY,KAC5BH,GAAWA,IACJ,CACLI,SAAUP,EACVQ,aAAcP,EACdQ,YAAaT,EACbU,YAAaT,IAEd,CAACD,EAAaC,EAAaE,IAExBQ,EAAMC,EAAuB,MAC7BC,EAAmBD,GAAO,IACzBE,EAAOC,GAAYC,EAASX,IAC7BE,SAAEA,EAAFE,YAAYA,EAAZC,YAAyBA,EAAzBF,aAAsCA,GAAiBM,EAG7D,IAAIG,EAAkC,KACtC,MAAOC,GAAMF,EACX,IACE,IAAIG,EAAe,KACjBF,EAAmBtB,OAAOyB,sBAAsB,KAGzCP,EAAiBQ,SACpBN,EAASV,KAEXQ,EAAiBQ,SAAU,OAuEnC,OAlEAtB,EAAU,KACJY,EAAIU,SACNH,EAAGI,QAAQX,EAAIU,SAEV,KACLJ,GAAoBtB,OAAO4B,qBAAqBN,GAChDC,EAAGM,eAEJ,CAACP,EAAkBC,IAGtBxB,EAAmB,KACjB,MAAM+B,EAAqBC,KAAKC,IAAIpB,EAAWC,IAAiBJ,EAC1DwB,IACFjB,EAAIU,UACLV,EAAIU,QAAQQ,aAAelB,EAAIU,QAAQS,cACtCnB,EAAIU,QAAQU,YAAcpB,EAAIU,QAAQW,aACpCC,EAAQ1B,EAAWC,EAIzB,GAAIiB,EAeF,YAdIG,EAKFb,EAAS,CACPR,SAJAC,EAAeD,EACXC,EACAD,GAAYC,EAAeD,GAG/BE,YAAAA,EACAC,YAAAA,EACAF,aAAAA,IAGFN,GAAYA,EAASK,IAMzB,IAAI2B,EACAC,EAAS1B,EACT2B,EAAS1B,EACTkB,GACFM,EAAQD,EAAQzB,EAAeD,EAAWG,EAAcH,EACxD4B,EAAST,KAAKW,IAAI5B,EAAaF,KAE/B2B,EAAQD,EAAQxB,EAAcF,EAAWC,EAAeD,EACxD6B,EAASV,KAAKY,IAAI5B,EAAaH,IAEjCQ,EAAS,CACPR,SAAUA,EAAW2B,EAAQ,EAC7BzB,YAAa0B,EACbzB,YAAa0B,EACb5B,aAAcD,KAEf,CACDA,EACAE,EACAC,EACAF,EACAN,EACAS,EACAP,IAGK,CAAEG,SAAaA,MAAaI,IAAAA"}