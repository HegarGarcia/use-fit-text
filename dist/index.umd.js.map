{"version":3,"file":"index.umd.js","sources":["../index.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\n/**\n * React hook that iteratively adjusts the font size so that text will fit in\n * a div.\n *\n *   - checks if text is overflowing by using `scrollHeight` and `offsetHeight`\n *     https://stackoverflow.com/a/10017343/101911\n *   - uses binary search; makes a maximum of 5 adjustments with a resolution\n *     of 5% font size from 20-100%\n */\nconst useFitText = () => {\n  const MIN_FONT_SIZE = 20;\n  const MAX_FONT_SIZE = 100;\n  const RESOLUTION = 5;\n\n  const ref = useRef<HTMLDivElement>(null);\n\n  const [state, setState] = useState({\n    fontSize: MAX_FONT_SIZE,\n    fontSizePrev: MIN_FONT_SIZE,\n    fontSizeMax: MAX_FONT_SIZE,\n    fontSizeMin: MIN_FONT_SIZE,\n  });\n  const { fontSize, fontSizeMax, fontSizeMin, fontSizePrev } = state;\n\n  useEffect(() => {\n    const isDone = Math.abs(fontSize - fontSizePrev) <= RESOLUTION;\n    const isOverflow =\n      !!ref.current &&\n      (ref.current.scrollHeight > ref.current.offsetHeight ||\n        ref.current.scrollWidth > ref.current.offsetWidth);\n    const isAsc = fontSize > fontSizePrev;\n\n    // return if the font size has been adjusted \"enough\" (change within RESOLUTION)\n    // reduce font size by one increment if it's overflowing\n    if (isDone) {\n      if (isOverflow) {\n        const fontSizeNew =\n          fontSizePrev < fontSize\n            ? fontSizePrev\n            : fontSize - (fontSizePrev - fontSize);\n        setState({\n          fontSize: fontSizeNew,\n          fontSizeMax,\n          fontSizeMin,\n          fontSizePrev,\n        });\n      }\n      return;\n    }\n\n    // binary search to adjust font size\n    let delta: number;\n    let newMax = fontSizeMax;\n    let newMin = fontSizeMin;\n    if (isOverflow) {\n      delta = isAsc ? fontSizePrev - fontSize : fontSizeMin - fontSize;\n      newMax = Math.min(fontSizeMax, fontSize);\n    } else {\n      delta = isAsc ? fontSizeMax - fontSize : fontSizePrev - fontSize;\n      newMin = Math.max(fontSizeMin, fontSize);\n    }\n    setState({\n      fontSize: fontSize + delta / 2,\n      fontSizeMax: newMax,\n      fontSizeMin: newMin,\n      fontSizePrev: fontSize,\n    });\n  }, [fontSize, fontSizeMax, fontSizeMin, fontSizePrev, ref]);\n\n  return { fontSize: `${fontSize}%`, ref };\n};\n\nexport default useFitText;\n"],"names":["ref","useRef","useState","fontSize","fontSizePrev","fontSizeMax","fontSizeMin","useEffect","isDone","Math","abs","isOverflow","current","scrollHeight","offsetHeight","scrollWidth","offsetWidth","isAsc","setState","delta","newMax","newMin","min","max"],"mappings":"iOAgBQA,EAAMC,SAAuB,QAETC,WAAS,CACjCC,SANoB,IAOpBC,aARoB,GASpBC,YARoB,IASpBC,YAVoB,wFActBC,2BACQC,EAASC,KAAKC,IAAIP,EAAWC,IAblB,EAcXO,IACFX,EAAIY,UACLZ,EAAIY,QAAQC,aAAeb,EAAIY,QAAQE,cACtCd,EAAIY,QAAQG,YAAcf,EAAIY,QAAQI,aACpCC,EAAQd,EAAWC,KAIrBI,EACEG,GAKFO,EAAS,CACPf,SAJAC,EAAeD,EACXC,EACAD,GAAYC,EAAeD,eAG/BE,cACAC,eACAF,aAOFe,EACAC,EAASf,EACTgB,EAASf,EACTK,GACFQ,EAAQF,EAAQb,EAAeD,EAAWG,EAAcH,EACxDiB,EAASX,KAAKa,IAAIjB,EAAaF,KAE/BgB,EAAQF,EAAQZ,EAAcF,EAAWC,EAAeD,EACxDkB,EAASZ,KAAKc,IAAIjB,EAAaH,IAEjCe,EAAS,CACPf,SAAUA,EAAWgB,EAAQ,EAC7Bd,YAAae,EACbd,YAAae,EACbjB,aAAcD,MAEf,CAACA,EAAUE,EAAaC,EAAaF,EAAcJ,IAE/C,CAAEG,SAAaA,UAAaH"}